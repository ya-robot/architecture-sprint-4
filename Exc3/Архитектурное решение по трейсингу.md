## Внедрение трейсинга

Проанализировав текущую архитектуру системы становится очевидным, что слабым местом (потеря статусов заказов) являются
все сегменты, которые общаются через Message Bus(RabbitMQ) и могут невалидно обрабатывать заказ. Так как успешно выполненый заказ является прямым следствием прибыли для компании, в первую очередь следует отрисвоать весь цикл движения заказа в системе соформировав трейс (добавить сквозной orderID и orderStatus) от начала создания заказа до завершения цикла операций.

Конечно же, рекомендуется добавить повсеместный трейсинг через SDK OpenTelemetry в свои сервисы и интегрировать его с клиетскими библиотеками инфраструктуры, например, в Postgres Connection Pool добавить Query Tracer, который в рамках АПИ операции позволит определить сколько выполнялась та или иная транзакция в базе данных, возникли ли проблемы, или в RabbitMQ Client добавить Consumer/Producer Tracer, чтобы отслеживать движение сообщения через Message Bus.

## Мотивация

Использование трассировки в веб-системе необходимо для повышения наблюдаемости, особенно в сложных архитектурах, таких как микросервисы. Вот основные причины, по которым трассировка должна быть интегрирована в систему:

1. End-to-End
Трассировка дает полное представление о том, как запросы проходят через вашу систему, начиная с фронтенда и заканчивая внутренними службами и базами данных. Каждый запрос отслеживается с помощью уникального идентификатора трассировки, что позволяет разработчикам визуализировать весь путь запроса, включая все взаимодействия со службами и время, затраченное на каждый шаг. Такая наглядность крайне важна для диагностики проблем производительности и понимания взаимосвязей между различными сервисами.

2. Оптимизация производительности
Анализируя трейсы, команды могут выявить узкие места в производительности и проблемы с задержками в своих приложениях. Каждый трейс состоит из нескольких участков, где каждый участок представляет собой определенную операцию (например, вызов API или запрос к базе данных). Такая подробная разбивка помогает точно определить, какие операции выполняются медленно и как они влияют на общее время отклика. Например, если определенный вызов службы постоянно занимает больше времени, чем ожидалось, его можно оптимизировать, чтобы улучшить качество обслуживания пользователей.

3. Анализ первопричины
При возникновении проблем трассировка позволяет ускорить анализ первопричины, связывая события в нескольких службах. Логи предоставляют информацию об отдельных событиях, но трассировка показывает, как эти события взаимодействуют в системе. Эта возможность позволяет командам быстро определить, какая служба или компонент ответственны за проблему, тем самым сокращая Mean Time to Resolution (MTTR). Например, если пользователи сообщают о медлительности во время транзакции, трассировка может показать, исходит ли задержка от платежного сервиса или от другого компонента рабочего процесса.

4. Расширенное взаимодействие
В микросервисных архитектурах разные команды часто управляют разными сервисами. Трассировка позволяет выяснить, где возникают ошибки и какая команда отвечает за их устранение. Такая прозрачность улучшает взаимодействие между командами, поскольку они могут быстро выявить зависимости и понять, как изменения в одном сервисе могут повлиять на другие.

5. Улучшенный мониторинг и алёртинг
Интеграция трассировки с инструментами мониторинга расширяет возможности алёртинга. Когда показатели производительности падают ниже допустимых порогов, трассировка может обеспечить контекст для этих предупреждений, показывая конкретные пути, по которым шли запросы, и места сбоев. Такая интеграция помогает командам более эффективно реагировать на инциденты.

6. Содействие непрерывному совершенствованию
Благодаря знаниям, полученным в результате трейсинга, организации могут постоянно совершенствовать свои системы. Понимая, как взаимодействуют сервисы, и выявляя области для улучшения, команды могут внедрять изменения, которые со временем повышают производительность и надежность.

## Предлагаемое решение

Использование официального SDK OpenTelemetry с экспортом в ранее развернутый OpenTelemetry Collector (в Exc2). Для этого потребуется минимальная доработка существующего ПО. Дополнительно на уровне ПО следует использвать инеграции клиентов Postgres и RabbitMQ с OTEL TracerExporter, чтобы расширить область видимости трейса.

[Обновленная Диаграмма С4](https://drive.google.com/file/d/13qf6S62QTpgoIycasrGFE8d9a3oWYpyX/view?usp=sharing)

## Компромиссы

Явных препяствий для внедрения трейсинга нет. Имеется широкий выбор SDK под все популярные языки разработки, в том числе и по те, которые используются в текущих сервисах.

Неочевидным препятсвием может быть некомпетентность текущей команды, которая не имела ранее опыта и экспертизы по данному вопросу. Тут стоит отложить внедрение и направить сотрудников, ответсвенных за реализацию на курсы повышения квалификации (либо самостоятельно изучение). По завершении изучения вопроса трейсинга современных приложений, приступить к внедрению.

## Безопасность

Так как визуализация плнируется прямо в Grafana с возможностью прицепки логов из Loki (по traceID), можно закрыть графану на уровне аутентификации своим Identity Provider и ролями доступов.

Дополнительно можно включить Web Service Firewall и настроить его на разрешение работы только из под внутренней сети организации (внутренний контур, enterprise VPN).